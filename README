# `git_flashback`

`git_flashback` is a Python library which lets you **load modules from the past** and thus **unpickle objects from the past**, by remembering their source code with git.

This is implemented with *transparent git snapshots* (which commit and tag your codebase, without affecting your working directory), and *transparent module loading* (which loads their code directly within the git filesystem, without affecting your working directory).

The intended use case is reproductible machine learning experiments. But, `git_flashback` is agnositic to external libraries such as torch, and can be used as a generic tool for temporarily restoring code to its older versions.

## Example 1: unpickling from the past

First, call `snapshot` to (transparently) commit and tag your codebase. You can then pickle your objects normally. 

```python
import git_flashback import snapshot

timestamp = snapshot()
print(timestamp) # => 2022-05-19T15:00:16.264685

import torch 

class Model(torch.nn.Module):
    def forward(self):
        return 1

torch.save(Model(), f"model.pt") # also compatible with pickle

# Figure 1: `snapshot` commits your code and tags it with a timestamp
```


Modify your code without fear. Later, `flashback` to the old codebase when loading your objects. This transparently loads the required modules from your snapshot, rather than the modified ones in your current filesystem.

```python
import git_flashback import flashback
import torch

class Model(torch.nn.Module):
    def forward(self):
        return 2

with flashback("2022-05-19T15:00:16.264685"): 
    model = torch.load("model.pt")

print(model()) # => 1

# Figure 2: `flashback` rewires imports so that modules load from the past
```

Regardless of your code changes and your package structure, `model` will behave *exactly as when saved*. 

### Workflow tips
It is recommended to snapshot as soon as possible, before the rest of your imports. This is to avoid delays in producing the snapshot (if your modules takes seconds to load, you might edit the code before the snapshot is produced).

```python
import git_flashback import snapshot
timestamp = snapshot()

# all imports go right below
import torch
import csv 
import os

...

# Figure 3: `snapshot` should be called before imports
```

Finally, one good way of working is to simply save all artifacts in a directory named with the timestamp. This is a natural way of bundling the timestamp alongside the saved objects.

```python
...

os.mkdir(f"experiments/{timestamp}")
torch.save(f"experiments/{timestamp}/model.pt")
csv.write(f"experiments/{timestamp}/losses.csv")

# Figure 4: save the timestamp alongside artifacts, for instance, by naming their directory
```

For conveniance, `flashback` will ignore everything before the rightmost forward slash, so a path like `"experiments/2022-05-19T15:00:16.264685"` can be passed directly to it.

```python
with flashback("experiments/2022-05-19T15:00:16.264685"): 
    # loads the snapshot "2022-05-19T15:00:16.264685"
    ... 
```


### Back to the future (past code editing)
Timestamps are just git tags, and so they can be checked out, letting you inspect and debug your past experiments.

```bash 
git checkout 2022-05-19T15.00.16.264685
# (note that any ':' character must replaced by '.' when checking out, because of a git limitation)
```

**When attempting to load from a timestamp which matches the current `HEAD`, `snapshot` will return the current tag (doing nothing) and `flashback` will instead load from the present (does nothing also).**
For example, after the checkout, the following code unpickles from the present, because the timestamp matches:

```python
# currently in 2022-05-19T15:00:16.264685

# no new snapshot is created, the current tag is returned
print(snapshot()) # => "2022-05-19T15:00:16.264685"

class Model(torch.nn.Module):
    def forward(self):
        return 3 # edited

with flashback("2022-05-19T15:00:16.264685"): 
    # loads from the present
    model = torch.load("model.pt") 
    
print(model()) # => 3

# Figure 5: when a past snapshot is checked out, `snapshot` and `flashback` become no-ops
```

This is a bit hard to see in a contrived example, but this makes it easy to checkout a past snapshot, edit its code, and verify that the changes work as desired. Afterwards, they can be committed normally:

```bash
git add .
git commit -m "Modified experiment 2022-05-19T15:00:16.264685"
# => 4a2a14084b044d90f892f6201dd89dadc36db7a5
git checkout main
```

After all this, and so it is also possible to flashback to commits directly (git tags are just pointers to commits):

```python
# currently in `main`

with flashback("4a2a14084b044d90f892f6201dd89dadc36db7a5"): 
    model = torch.load("model.pt")

print(model()) # => 3

# Figure 6: from `main`, loading a modified version of the past 
```


## Example 2: compring past modules

When debugging or after peforming refactors, it is often desirable to compare the new code's behavior to its older versions. `git_flashback` provides a conveniant way of doing so, by loading code from past snapshots or commits.

```python
from git_flashback import flashback
import my_module

# `flashback` to an older commit; any git reference is valid!
with flashback("fcfee1d161cd4dd9e07af841b1166dbbd8a07980"): 
    import my_module as my_old_module

assert my_module.f() == my_old_module.f()

# Figure 7: compare two different versions of the same module
```

It is important to note that everything is duplicated, including the class definitions but also the subdependencies themselves. This means that any state modification will be remain isolated within each module.


## Sharing snapshots
To share snapshots, simply push their tags to github. 

```bash
git push 2022-05-19T15:00:16.264685
```

Then, make sure to pull them locally before calling `flashback` (tags must be pulled manually).

```bash
git clone my-repo
cd my-repo
git pull 2022-05-19T15:00:16.264685
```

Alternatively, when the `autopull` flag is true, `flashback` will attempt to `git pull` any missing snapshot automatically. 

```python
flashback("2022-05-19T15:00:16.264685", autopull=True)

# Figure 8: the `autopull` option will pull snapshots remotely
```


## Cleaning up old snapshots

Because snapshots are just diffs, they are very lightweight, provided that `gitignore` is configured properly. Still, it may be desirable to delete old versions to avoid clutter. To do so, just remove their tags from git, leaving them to be garbage collected. For instance, if all tags are saved as subdirectories of in `experiments/`, the following command clears out all other ones:

```bash
comm -23 <(git tag -l) <(ls experiments/) | xargs -n 1 git tag -d
```

## Caveats

### Typing and class duplication
Because objects loaded from the past come from a different codebase, `isinstance` and `issubclass` will return `False` when compared to classes from the present (which is technically true, but may be undesirable).

For this reason, `git_flashback` exports the following functions:
    - `isinstance_by_name` and `issubclass_by_name`, which considers classes to be equal if they have the same name.
    - `isinstance_by_qualname` and `issubclass_by_qualname`, which considers classes to be equal if they have the same name *and packaging path*.

Of course, it is also possible to manually override `__instancecheck__` and `__subclasscheck__` to implement any desired behavior.

### Dynamic imports
Python does not support loading multiple versions of the same dependencies by default. So, this library works by clearing out
`sys.modules`, repopulating it with old code, and finally restoring it back to what is was. **As such, any dynamic imports of uncached modules in past code will look at new code.** To avoid this, avoid dynamic imports.


## Acknowledgements
This library is a small wrapper around [gitimport](), which carries most of the implementation weight. :) 